## Synchronous, Asynchronous 의 차이점을 설명하세요.
```markdown
Sync(동기)와 Async(비동기)의 차이는 작업 완료에 대한 콜백처리를 바로 하느냐 안하느냐에 차이가 있다고 생각합니다
다르게 말하자면 해당 작업의 주체성이 호출한 쪽에 있는지, 호출 당한쪽에 있는지로 판별됩니다

메인 작업장에서 A작업을 실행한다고 했을 때
Sync라면 메인 작업장에서 A작업의 결과를 계속해서 체크하고 신경씁니다.
또한 작업이 끝나면 곧바로 콜백 함수를 통해 추가 작업을 처리하죠
이 경우 A작업의 주체성은 메인 작업장에 있습니다

하지만 Async는 메인 작업장에서 A작업의 결과에 관심이 없습니다.
따라서 작업이 끝나면 호출당한 쪽에서 직접 콜백함수를 전달하며, 콜백함수가 오더라도 메인 작업장에서 곧바로 처리하지 않을 수도 있습니다
이 경우는 A작업의 주체성은 호출당한 메서드에 있다고 봅니다

따라서 저는 Sync, Async를 작업 결과에 대한 처리 관점, 혹은 작업의 주체성이 누구한테 있냐로 비교를 하였습니다
```

## Blocking, Non-Blocking 의 차이점을 설명하세요.
```markdown
Blocking과 Non-Blocking의 차이는 제어권의 관점에서 차이가 있다고 생각합니다
메인 작업장의 작업을 수행할 수 있는 제어권 티켓으로 예로 들어보겠습니다

메인 작업장에서 A - B - C 의 작업이 있고 B가 Blocking 작업이라고 생각해보겠습니다
메인 작업장은 A를 완료하고 B에게 제어권 티켓을 전달합니다.
B는 작업이 완료되기 전까지 계속 제어권 티켓을 가지고 있습니다.
따라서 메인 작업장의 로직은 멈춰있겠죠
B는 작업이 완료되면 제어권 티켓을 다시 돌려줌으로써 메인 작업장은 C의 작업을 진행합니다.

반대로 B가 Non-Blocking 작업이라고 생각해보겠습니다.
마찬가지로 메인 작업장에서 A를 완료한 후 B에 제어권 티켓을 넘깁니다.
B는 작업이 완료되지 않아도 제어권 티켓을 바로 메인 작업장에게 전달합니다(거의 호출 즉시)
따라서 메인 작업장은 B가 작업이 종료되지 않아도 로직이 멈추지 않고 바로 C 작업을 수행합니다

따라서 저는 Blocking, Non-Blocking의 차이를 제어권 티켓을 작업이 완료된 후에 주냐, 작업이 완료되지 않아도 바로 주냐로 비교하며,
쉽게 말하면 메인 작업장의 로직 흐름이 멈추냐, 안멈추냐로 비교할 수 있다고 생각합니다.
```

## Synchronous, Blocking / Asynchronous, Non-Blocking 의 차이점을 설명하세요.
```markdown
Sync-Blocking은 대표적으로 Java의 기본 동작입니다.
A작업이 수행된다면 해당 작업이 끝나서 결과가 나올때 까지 기다리고 작업이 완료되어 콜백함수가 호출되면 그 즉시 처리하는 방식입니다.
예시로는 Java의 syncronized 키워드가 있습니다.
해당 키워드는 다중 스레드에서 syncronized인 자원을 동시에 접근할 시, 하나의 스레드가 먼저 접근하면 바로 Lock을 걸어
나머지 스레드에서 접근을 하지 못하고 기다리게 함으로써 동시 접근을 막으므로, 스레드 간의 동일성을 보장하는 동기화 방식입니다.

반대로 Async-NonBlocking은 대표적으로 JavaScript에서 주로 사용하는 방식입니다.
A작업이 수행해도 그 결과가 끝날때까지 기다리는게 아닌, 바로 다른 B작업을 수행할 수 있게 하며 A작업이 완료되어 콜백함수가 반환되면,
그 즉시 처리할 수도 있고, 하고 있던 작업을 완료한 후 처리할 수도 있습니다.
예를 들면 화면에서 사용자가 상품 구매 API를 호출하면 구매로직이 완료될때까지 아무것도 못하고 기다리는 것이 아닌,
다른 화면에서 다른 동작을 할 수 있고 내부적으로는 상품 구매 로직을 알아서 처리합니다.
```
