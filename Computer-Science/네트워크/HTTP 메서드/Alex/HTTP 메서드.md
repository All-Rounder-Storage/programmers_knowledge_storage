# HTTP 메서드
<br>

## URI 설계

- URI는 계층구조를 활용해야한다
- 리소스를 식별해야 한다.

<br>

## 리소스란

- 회원을 등록하고 수정하고 조회하는 것이 리소스가 아니다
- 리소스는 “회원” 그 자체이다

<br>

## 리소스 vs 행위

| 리소스 | 행위 |
| --- | --- |
| 회원 | 조회, 등록, 삭제, 변경 |

<br>

## 행위란

- 행위란 메서드이다

| Method      | Description |
|--------|---------------|
| GET    | 리소스 조회                 |
| POST   | 요청 데이터 처리, 주로 등록에 사용   |
| PUT    | 리소스 대체, 해당 리소스 없을 시 생성 |
| PATCH  | 리소스 부분 변경              |
| DELETE | 리소스 삭제                 |
- 기타 행위(메소드)
    - HEAD :  GET과 동일하지만 메시지(body) 부분을 제외하고, 상태 줄과 헤더만 반환
    - OPTIONS : CORS에서 주로 사용하는 것으로 대상 리소스에 대한 통신 가능 옵션(메서드)을 반환

```markdown
💡 아래 회원 정보 관리 API를 예시로 들어보자

- 회원 목록 조회
	- GET /members

- 회원 조회
	- GET /members/100

- 회원 등록 : POST
	- POST /members

- 회원 수정
	- PUT /members/100
	- PATCH /members/100

- 회원 삭제
	- DELETE /members/100
```

### GET

- 리소스 조회
- 서버에 전달 데이터는 쿼리파라미터를 통해 전달
- 최근 스펙에서는 GET 도 body를 허용해주지만 지원하는 곳이 많지 않음

### POST

- 새 리소스 생성(등록)
- 프로세스를 처리해야 하는 경우
    - 단순히 데이터 생성, 변경을 넘어선 프로세스의 상태가 변경되는 경우
        - ex) 결제 완료 → 배달시작 → 배달 완료
    - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
- 다른 메서드로 처리하기 애매한 경우

    ```markdown
    ex) 조회하기 위한 요청 데이터를 Json으로 넘겨야 한다면?
    -> GET은 body를 지원하지 않는 곳이 많기때문에 이런 애매할 때는 POST를 사용
    
    하지만 보통 캐싱같은 부가적인 처리는 GET을 이용해서 많이 하기 때문에
    웬만하면 조회는 GET으로 하는게 유리합니다
    ```


### PUT

- 리소스를 대체한다
    - 리소스가 있을 시 대체
    - 리소스가 없을 시 생성

    ```markdown
    ex) 폴더 덮어씌우기
    ```

- 클라이언트가 리소스 위치를 알고 있어야 한다 (POST 와의 차이점)
    - ex) PUT /members/100

### PATCH

- 리소스 부분 변경

### DELETE

- 리소스 제거
- `DELETE /members/100 : 100번 회원 삭제`

<br>

### PUT vs PATCH
`회원번호가 100번인 회원의 정보는 이렇다고 가정해보자`

```markdown
username : gibeom
age : 62

-----------------------------------------------------
PUT /members/100
{
	"age" : 26
}

결과 : /members/100
{
	"age": 26    <-- 덮어씌워져서 username이 사라짐
}

-------------------------------------------------------
PATCH /members/100
{
	"age" : 26
}

결과 : /members/100
{
	"username": "gibeom",
	"age": 26
}
```

<br>

## HTTP 메서드의 속성

- **안전(Safe Methods) : 호출해도 리소스를 변경하지 않는지?**
    - GET을 제외한 POST, PUT, PATCH, DELETE 는 안전하지 않다 (데이터 변경때문)
    - 안전은 해당 리소스만 고려하고 외부적인 요인은 고려하지 않는다
- **멱등(Idempotent Methods) : 한번 호출하든 두 번 호출하든 100번 호출하든 결과는 똑같은지?**
    - POST, PATCH를 제외하고는 나머지는 다 멱등하다 (POST는 중복 결제 가능)
    - 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음
    - 멱등한경우에는 자동 복구 메커니즘을 활용하여 서버가 Timeout 떴을때 클라이언트가 같은 요청을 시도함
- **캐시가능(Cacheable Methods) : 응답 결과 리소스를 캐시해서 사용해도 되는지?**
    - 보통 GET, HEAD 정도로만 캐시로 사용

        ```markdown
        캐시를 하려면 똑같은 리소스라는 키가 맞아야 한다
        하지만 POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 쉽지 않다
        ```

<br>


## 클라이언트 → 서버로 데이터 전송 방법

### 쿼리 파라미터

- GET 에 사용
- 주로 정렬 필터 (검색어)

### 메시지 바디

- POST, PUT, PATCH
- 회원가입, 리소스 등록 및 변경, 주문 등

<br>

## 전송 4가지 상황

### 1. 정적 데이터 조회

- 이미지, 정적 텍스트 문서 등
- 요청 데이터는 따로 없고 리소스 path만 있으면 됨

### 2. 동적 데이터 조회

- 주로 검색어
- 쿼리 파라미터를 통해 요청 데이터 전송

### 3. HTML Form 데이터 전송

```html
<form action="/save" method="post">
	<input type="text" name="username" />
	<input type="text" name="age" />
	<button type="submit">전송</button>
</form>
```

- acton : PATH
- method : **GET, POST만 가능**
  - AJAX 같은 기술을 사용해서 해결 가능
- Content-Type: application/x-www-form-urlencoded 이 Default

| GET | POST |
| --- | --- |
| name 값들이 쿼리 파라미터로 담긴다 | body에 JSON 형태로 담긴다 |

### 4. HTTP API 데이터 전송

- 모든 메서드 사용 가능 (GET, POST, PUT, PATCH, DELETE)
- 서버 to 서버, 앱 클라이언트, 웹 클라이언트 등과 통신할때 사용
- Content-Type: application/json을 주로 사용 (사실상 표준)
  - 종류 : TEXT, XML, JSON 등

<br>

## HTTP API 설계 예시

### POST vs PUT (컬렉션 vs 스토어)

| POST 기반 등록 (컬렉션)          | PUT 기반 등록 (스토어) |
|---------------------------|--------------------------|
| 서버가 새로 등록된 리소스 URI를 생성해준다 | 클라이언트가 직접 리소스의 URI를 지정한다 |


| 컬렉션 | 스토어 |
| --- | --- |
| 서버가 관리하는 리소스 디렉토리 | 클라이언트가 관리하는 리소스 저장소 |
| 서버가 리소스의 URI를 생성하고 관리 | 클라이언트가 리소스의 URI를 알고 관리 |

### 컨트롤 URI

- HTML Form에서는 GET, POST만 지원하므로 제약이 있다
- 또한 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행 시 사용
  - 최대한 리소스를 활용하여 설계를 해보고 안될 경우에 컨트롤 URI를 사용
- 따라서 이런 제약들을 해결하기 위해 URI에 **동사로 된 리소스 경로**를 사용

```markdown
💡 예시를 들어보자

회원 삭제
POST /members/{id}/**delete**
```