# 로드 밸런싱

## 이게 무엇인가요 ?

`Load` + `Balancing`

- **부하 분산을 목적**으로 하는 컴퓨터 네트워크 기술의 일종이다.

- 중앙처리장치 나 저장장치와 같은 컴퓨터 자원들에게 처리해야 할 작업을 나누는 것을 의미한다.

- 동시에 들어오는 수 많은 커넥션의 처리와 이를 요청 노드 중 하나로 전달할 수 있게 하는 것이다.

- 소프트 웨어 혹은 하드웨어 장비로 로드 밸런싱 처리를 할 수 있으며 이를 로드 밸런서 라고 부른다.

![loadBalancing](https://user-images.githubusercontent.com/49216939/185589574-8a297aaf-785a-40f1-9852-4ea3570c60eb.png)

[이미지 출처](https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/)

## 주된 사용 상황
- 주로 인터넷 서비스에 발생하는 트래픽이 많은 경우, 로드 밸런싱을 통해 여러 대의 서버에서 분산 처리할 수 있도록 한다.

```markdown
- 이로 인해 얻는 이점은 ?

- 🤞 부하로 인한 서버 마비의 위험을 덜어줄 수 있다.
- 🤞 접속자에게 양질의 서비스를 제공할 수 있다.
```

> 음...근데 트래픽이 많이지면 더 성능이 좋은 서버로 교체하면 되는거 아닌가요 ?
> **맞아요. 하지만 다른 방법도 존재 합니다.**

### Scale-up, Scale-out
Scale-up
- 기존 서버의 성능을 확장하는 방식

Scale-out
- 기존의 서버와 동일하거나 더 낮은 성능의 서버를 증설하는 방식
- 이 방식을 이용할 경우 부하 분산 처리를 위한 로드 밸런싱이 반드시 필요하다 !
- [데이터 정합성의 문제](#data-consistency-problem)를 해결해야 일관적인 서비스를 제공할 수 있다.(연결된 문단에서 자세히 살펴보자)

![scale up/out](https://user-images.githubusercontent.com/49216939/185591584-b7c6f23c-3378-45e7-b8a0-708112afed14.png)

[이미지 출처](https://hooni.net/95321)

- 스케일 UP/OUT 의 특징
- **비용적인 측면에서 Scale-Up 보다 Scale-out 이 더욱 효과적이다.**
- 오토 스케일링 기술을 활용할 수 있다.
- 오토 스케일링 이란 사용자가 미리 지정해놓은 오토 스케일링 정책에 따라 트래픽 발생 시, 미리 지정된 만큼의 자원이 늘어나도록 설정하는 기술
    - 클라우드 회사의 과금 정책
    
## 로드 밸런싱의 작동방식

`L4 로드 밸런싱`

- 전송 계층(Layer 4) 프로토콜의 헤더를 부하 분산에 이용하는 로드 밸런싱 방식
- 네트워크 계층의 IP, IPX 이나 전송 계층의 IP 주소, 포트번호, 맥주소, 전송 프로토콜 등을 바탕으로 부하를 분산한다.

- 패킷 레벨에서 로드를 분산하기 때문에 속도가 빠르고 효율이 좋다.
- 패킷의 내용은 볼 수 없어서 디테일한 라우팅은 어려우며, 사용자의 IP 가 계속 바뀐다면 연속적으로 서비스를 제공하기 어렵다.
- 데이터 내용의 복호화 과정이 없기에 안전성이 좋다.
- 로드밸런서의 가격이 비교적 저렴하다.


`L7 로드 밸런싱`

- 응용 계층(Layer 7) 프로토콜의 헤더를 부하 분산에 이용하는 로드 밸런싱 방식
- Http header, 쿠키등 과 같은 사용자의 요청을 기준으로 부하를 분산한다.
- 특정한 패턴을 지닌 바이러스를 감지해서 네트워크를 보호할 수 있고, dos/ddos 공격을 필터링 할 수 있어 보안 분야에서도 활용된다.

- 상위 계층에서 로드를 분산해서 L4 보다 섬세한 라우팅이 가능하며 캐싱이 가능하다.
- 비정상적인 트래픽을 필터링 해서 서비스 안정성을 올릴 수 있다.
- 패킷의 내용을 복호화 해야하기 때문에 L4 보다 높은 비용을 지불해야한다.
- 클라이언트의 인증서를 로드밸런서와 공유해야 하기에 공격자가 로드밸런서로 접근한다면 보안상의 위험이 존재한다.

## 로드 밸런싱 사용 기술
```markdown
NAT(Network Address Translation)
- Private IP -> Public IP 로 바꾸는데 사용하는 통신망의 변조 주소기
```

```markdown
DSR(Dynamic Source Routing protocol)
- 로드 밸런서 사용시 서버에서 클라이언트로 응답이 돌아가는 경우 목적지 주소를 스위치 주소의 IP 가 아닌 
  클라이언트의 IP 주소를 전달하여 네트워크 스위치를 건너 뛰고 클라이언트에게 바로 가게 하는 기술
```
```markdown
Tunneling
- 데이터 스트림을 가상의 파이프를 통해 전달하게 하는 기술
- 패킷 내 터널링 할 대상을 캡슐화하여 목적지까지 전송
    - 이 방식은 SSL 에서도 사용된다.
```

## 로드 밸런싱 기법
```markdown
라운드 로빈 방식
- 서버에 들어온 요청을 순서대로 돌아가며 배정하는 방식
- 클라이언트의 요청을 순서대로 분배하기 때문에 여러 대의 서버는 동일한 스펙을 가짐 
- 서버와의 연결이 오래 지속되지 않는 경우에 사용하기 적합
```
```markdown
가중 라운드 로빈
- 서버에 각각 가중치를 매기고, 가중치가 높은 서버에 클라이언트의 요청을 우선적으로 배분하는 방식
- 여러대의 서버가 서로 트래픽을 처리할 수 있는 능력이 다를 경우 사용되는 방식이다.
- 로드 밸런서가 각각의 가중치에 따라 분배하여 요청을 전달한다.
```
```markdown
IP 해시 방식
- 클라이언트의 IP 주소를 특정 서버로 매핑하여 요청을 처리하는 방식
- 클라이언트의 IP를 해싱해서 이를 토대로 분배를 한다.
- 클라이언트는 항상 동일한 서버로의 연결을 보장 받을 수 있다.
```
```markdown
최소 연결 방식
-요청이 들어온 시점에 가장 적은 연결 상태를 보이는 서버에 우선적으로 요청을 배분하는 방식
- 세션이 길어지거나, 트래픽이 일정하지 않은 경우 적합한 방식이다.
```
```markdown
최소 응답 시간 방식
- 서버의 현재 연결 상태와 응답시간을 모두 고려해 요청을 배분하는 방식
- 가장 적은 연결 상태, 가장 짧은 응답 시간을 보이는 서버에 우선적으로 요청을 배분한다.
```

## data consistency problem
> 데이터 정합성 문제

### 이게 뭔가요 ?
- 서버 부하 분산을 Scale-out 으로 처리하려고 하는 경우 각각의 서버마다 서로 일치하는 값을 가지고 있어야 한다.
- 하지만 세션 같은 경우 서버에 접근을 할 때마다 다른 세션을 사용한다면, 사용자 정보의 일관성을 유지할 수 없다. 
- 그래서 이러한 데이터 정합성을 해결하여야 부하 분산을 통해 정상적인 서비스를 제공할 수 있다.


### 해결 방법으로는 아래와 같은 처리를 해줄 수 있다.
- 세션 고정(Sticky Session) 
    - 첫 요청 이후의 모은 요청을 첫 요청을 처리한 서버로 고정한다.
        - 쿠키에 이용한 서버 정보를 저장해서 활용한다.
      
    - 하지만 결국 사용자가 접속하는 서버는 정해져 있기에 트래픽 몰림 문제에선 자유롭지 않다.
        - 서버 장애 발생 시 사용자의 세션 정보를 잃을 수도 있다.

![sticky](https://user-images.githubusercontent.com/49216939/185604028-1b612235-4704-4785-9fcd-30235fdaf2f7.png)

- Session Clustering
  - ※ 클러스터링 이란 여러 대의 컴퓨터들이 연결되어 하나의 시스템처럼 동작하도록 만드는 것, 이 개념을 적용해 처리하는 방식
  - All-to-All Session Replication (톰캣 지원)
      - 하나의 세션 저장소에 변경되는 요소가 발생할 경우 다른 모든 세션에 복제
          - 부하 분산을 위한 모든 서버가 세션 정보를 가져야 하여 많은 메모리 필요
          - 어느 서버에서든 세션 저장소에 값이 저장될 경우 복제를 해야하기에 성능 저하 발생 가능
      - 소규모일 때 좋은 효율을 보임

![all-to-all](https://user-images.githubusercontent.com/49216939/185603498-57ffe2fc-e952-4b09-8699-6dc8141d22ec.png)

- Primary-Secondary Session Replication(톰캣 지원)
    - Primary 서버는 Secondary 서버에 세션 객체 전체를 복제 합니다. 
      하지만 이외의 서버는 key 에 해당하는 JSESSION-ID 만 복사 하여 메모리 사용이 첫번째 방식보다 줄어듬
        - 이외의 서버들은 키를 이용해 Primary 서버에 요청해서 값을 받습니다.
    - 대규모일 때 좋은 효율을 보임
          
![primary-secondary](https://user-images.githubusercontent.com/49216939/185603329-cfd21498-c740-492c-b320-ed4b433bf281.png)
  
- Session Storage 분리
    -  세션 저장소를 각각의 서버가 가지지 않고 별도의 세션 저장소를 사용하는 것을 의미함
        - 각각의 서버에 세션 스토리지 정보를 입력하면 세션 공유 가능

![session storage](https://user-images.githubusercontent.com/49216939/185603870-09df75ca-72ba-4d40-bf57-a97c2fdf4a87.png)

### reference

- [post](https://tecoble.techcourse.co.kr/post/2021-11-07-load-balancing/)
- [post](https://mkki.github.io/interview/2018/12/20/qna-for-job-interview.html)
- [post](https://n-square.tistory.com/125)
- [post](https://hyuntaeknote.tistory.com/6)
- [post + 데이터 정합성 이미지 출처](https://hyuntaeknote.tistory.com/6)

- [youtube](https://www.youtube.com/watch?v=kYipnodgi2I)
- [youtube](https://www.youtube.com/watch?v=u4O4zHdiFhk)