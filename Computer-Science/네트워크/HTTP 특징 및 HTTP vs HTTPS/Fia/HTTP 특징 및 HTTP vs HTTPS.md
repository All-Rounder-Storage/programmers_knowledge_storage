# HTTP 특징 및 HTTP vs HTTPS

## HTTP 특징은 ?
- **클라이언트-서버 구조** 이다.
  ```markdown
  Request / Response 구조로 이뤄져 있다.
  1. 클라이언트가 서버에 요청을 보내고 응답을 대기한다.
  2. 서버가 요청에 대한 결과를 만들어서 응답한다.
  ```
- **Stateless(무상태) 프로토콜** 이다.
  ```markdown
  서버는 클라이언트의 상태를 유지(보존)하고 있지 않다.
  각각의 통신은 독립적으로 이루어진다.
  ex.
  클라이언트 : 아침에 수영 같이 가자.
  서버 : 그래
  클라이언트 : 수영 가자
  서버 : 어딜 ? 왜 ?
  이러한 특징으로 서버의 확장성이 높다.(서버 수를 쉽게 늘릴 수 있다)
  반면 클라이언트는 필요로 하는 데이터를 알리기 위해 부가적인 정보를 전송해야만 한다.
  ```
- **Connectionless(비연결형)** 이다.
  ```markdown
  요청을 주고 받을 때만 연결을 유지하는 모델이다.
  응답을 주고나면 연결을 해제한다.
  최소한의 자원으로 유지가 가능하다.
  서비스의 규모가 클 경우 비효율적인 상황이 발생하기도 한다.
  3-way handshake 시간이 추가 된다.
  ```

## 알고 넘어 갈 내용 3-way / 4-way handshake 란 ? 
- 정확한 전송을 보장하기 위한 기법 이다.
- **3-way Handshake**
  ```markdown
  TCP 통신을 이용하여 데이터를 **전송**하기 위해서 **네트워크 연결을 설정** 하는 과정 이다.
  통신을 할 두 주체가 모두 전송 준비를 마치고, 데이터 전달 전 준비 완료된 상태 임을 다른 쪽에서 알 수 있다.
  클라이언트와 서버 사이에서 3개의 segment 교환이 일어나며 동작 한다.
  아래와 같은 형태로 동작 한다.
  1. 클라이언트는 서버와 연결하기 위해  SYN(x) 을 보냅니다. (1번)
  2. 서버는 SYN 을 받고 클라이언트에 받았다는 신호인 ACK(x+1) + SYN(y)돌려주어 응답합니다. (2번)
  3. 클라이언트는 서버의 응답 ACK + SYN 을 받고, ACK(y+1)을 서버로 보냅니다. (3번)
  ```
  
- **4-way Handshake**
  ```markdown
  통신의 **접속 해제**를 해주는 과정 이다.
  아래와 같은 형태로 동작 한다.
  1. 클라이언트가 연결 종료를 알리는 FIN 을 보냅니다.
  2. 서버는 FIN 을 받은 후 클라이언트에게 확인함을 알리는 ACK 를 보냅니다.
  3. 서버는 연결 종료의 준비가 완료 되면, 이를 알리는 FIN 을 클라이언트에게 보냅니다.
  4. 클라이언트는 해지 준비의 확인을 알리는 ACK 를 서버로 보냅니다.
  ```
  
## HTTP VS HTTPS

- **HTTP(HyperText Transfer Protocol)**
  + 데이터를 주고 받기 위한 프로토콜 이다.

- **HTTPS(HyperText Transfer Protocol Secure)**
  + HTTP 에 데이터 **암호화**가 추가된 프로토콜 이다.
  
- **HTTPS 의 암호화**
  ```markdown
  <b>대칭키 암호화 방식(비공캐 키 암호방식)</b>
  클라이언트와 서버가 동일한 키를 사용해 암호화/복호화 처리 과정을 진행한다.
  키가 노출되면 위험하다. 하지만 동일한 키를 이용하기 때문에 속도는 빠르다.
  
  <b>비대칭키 암호화 방식(공개 키 암호방식)</b>
  하나의 쌍으로 이루어진 공개키와 개인키를 이용해 암호화/복호화를 진행한다.
  키가 노출되어도 비교적 안전하다. 하지만 속도는 느리다.
  공개키 : 모두에게 공개 가능한 키
  개인키 : 나만 알아야 하는 키
  공개키로 암호화 하면 개인키로만 복호화가 가능하다(개인키는 내 소유로 나만 볼 수 있다.)
  개인키로 암호화 하면 공개키로만 복호화가 가능하다(공개키는 모두에게 공개, 내가 인증한 정보라는 신뢰성 보장이 가능하다.)
  ```

## 핵심적인 차이점은 ?
- **SSL 인증서**(보안 소켓 계층)를 사용하는 것
- SSL 이란 ?
    + 암호화 기반 인터넷 보안 프로토콜 이다.
    + 서버와 브라우저 사이에서 암호화된 연결을 가능하게 한다.
    + 민감한 정보를 주고 받을 때 도난, 변조, 도청 을 방지 한다.
    + URL 프로토콜은 https 이고, 443 포트를 기본으로 사용한다.
    + 현재는 TLS 를 이용하지만 통신 보안 프로토콜을 통틀어 SSL 이라고 부른다.

- SSL 통신 원리
    1. **클라이언트는 특정 주소에 접근 시 해당 서버에 요청을 보냄 (ClientHello)**
       - 이때 난수 데이터, 암호화 정보, 암호화 기법, 세션 아이디 등을 함께 요청한다.
    2. **서버는 클라이언트에게 요청을 받으면 답변을 보낸다. (ServerHello)**
       - 이때 난수 데이터(클라이언트 정보와 다름), 암호화 기법, 인증서(CA, 도메인, 공개키) 보낸다.
    3. **인증서 검토를 진행한다.**
       - 서버가 전달한 인증서가 신뢰할 수 있는 인증서 인지, 실제 해당 CA 에서 발급 받은 본인지 검토 한다.
    4. **Premaster secret 송수신**
       - ClientHello, ServerHello 에서 송수신한 난수 데이터를 조합하여 Premaster secret을 생성한다.
       - 이를 ServerHello 에서 전달받은 공개키로 암호화를 진행한다. 
       - 이는 서버가 가진 개인키로만 복호화를 할 수 있다.
    5. **통신 키 생성**
       - Premaster secret 을 토대로 세션 키와 마스터 시크릿을 생성한다.
       - 이를 통해 클라이언트와 서버가 동일한 키를 보유하여 암호화 통신이 가능해진다.
    6. **데이터 송수신**
       - 대칭키 암호화 방식으로 암/복호화하여 통신한다 (세션 키 이용)
    7. **세션 종료**
       - 연결이 끊기면 세션키는 폐기 한다.
   
![SSL_LOGIC](https://user-images.githubusercontent.com/49216939/174294656-e6b12bb0-8cd8-4369-8fa5-264548592fb4.png)

[ssl 통신 원리 발췌 본문](https://blog.itcode.dev/posts/2021/08/18/about-ssl)

## HTTP 1.1 VS HTTP 2.0

- HTTP 1.1 의 문제점
  - 통신 하나 당 한 개의 요청만 처리할 수 있다.
    - 요청과 응답이 순차적으로 이뤄진다.
    - 동시에 자원을 주고 받을 수 없다.
    - image, css, script 를 처리하려면 one by one 이기 때문에 대기시간이 길어진다.
  - HOL(Head of Line) Blocking 이 발생할 수 있다.
    - 네트워크에서 같은 큐에 있는 패킷이 첫번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상이다.
  - RTT(Round Trip Time) 증가
    - 커넥션 마다 TCP 상에서 3-way handshake 가 반복적으로 일어나서 시간을 지연 시킨다.
  - 무거운 Header 구조
    - 매 요청마다 중복된 헤더 값을 전송하여, 반복적인 헤더가 전송 되고, 쿠키 정보를 포함하여 헤더 크기가 증가 한다.

<b> HTTP 2.0 은 1.1의 이러한 성능 저하를 해결하기 위해 프로토콜의 성능에 초점을 맞춰 수정한 버전이다.</b>

- HTTP 2.0 특징
  - 커넥션 하나로 여러개의 메세지를 주고 받고, 응답은 순서에 상관 없이 stream 으로 주고 받는다.(Multiplexed Streams)
  - 리소스 로드 지연 문제를 리소스 간의 의존관계에 따른 우선 순위를 설정하여 해결하였다.(Stream Prioritization)
  - 클라이언트가 요청하지 않은 리소스를 서버가 먼저 전송할 수 있다.(Server Push)
    - 이를 통해 클라이언트의 요청을 최소화 할 수 있다.
  - 헤더 정보를 HPACK 방식으로 압축한다.(Header Compression)
    - Static/Dynamic Header Table 개념을 이용하여 중복 검출, 
      해당 테이블의 index 값 + 중복되지 않은 헤더 정보를 huffman encoding 방식으로 인코딩 하여 데이터 전송 한다.
      ```markdown
      Static/Dynamic Header Table
      - Static Header Table : http/2 헤더로 자주 사용되는 key-value 값 쌍을 저장하고 있는 테이블
      - Dynamic Header Table : 한번 전송 또는 수신한 header 의 key-value 값을 임의로 저장하는 역할을 수행하는 테이블
      huffman Encoding
      - 통계를 활용해 압축하는 기법
      - 자주 나오는 문자열 순서대로 짧은 비트맵으로 매핑하여 데이터를 압축하는 기법이다.
      - JPEG MPEG 압축 방식에 이용되고 있다.
      ```
![HTTP](https://user-images.githubusercontent.com/49216939/174300100-2b2bc405-5245-4578-afed-2995d7388994.png)